[{"title":"iterm2 + zsh + oh my zsh 终端","date":"2017-05-10T05:11:42.000Z","path":"2017/05/10/iterm2 + zsh + oh my zsh 终端/","text":"系统默认的终端，在使用上有不少不如意的地方。比如命令复制、命令重复输入。这顿google + baidu 之后决定使用： iterm2 zsh oh my zsh 打造自己终端。 一、下载 iterm2 这里推荐是用 brew 安装 1$ brew cask install iterm2 二、安装oh my zsh 官网推荐安装1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 三、切换bash为zsh mac系统默认使用的为bash、可以使用下面命令查看当前系统使用的命令行 1$ echo $SHELL 切换为zsh1$ chsh -s /bin/zsh 在切换为zsh之前，本地通过 nvm 安装了 node。切换之后，命令行会失效。 四、迁移原有命令行指令 12$ open ~/.bash_profile$ open ~/.zshrc 将需要使用的命令从 bash_profile 复制到 zshrc，变保存。","tags":[{"name":"杂","slug":"杂","permalink":"http://getjll/tags/杂/"}]},{"title":"this指向","date":"2017-04-28T07:19:42.000Z","path":"2017/04/28/this指向/","text":"作为函数调用例子一123456function test() &#123; this.test = 1 console.log(this, this.test)&#125;test() // global对象，1 例子二1234567891011let testValue = 2;let obj = &#123; testValue: 1, testMethod: function () &#123; console.log(this, this.testValue) &#125;&#125;;obj.testMethod() // obj, 1let testMethod = obj.testMethodtestMethod() // global对象, 2 函数直接调用this指向调用当前函数的对象。 构造函数调用123456function test() &#123; this.test = 1 console.log(this, this.test)&#125;new test() // test &#123;test: 1&#125;, 1 作为构造函数调用，this指向新创建的对象 bind、call／apply调用12345678910111213141516171819let type = 'global'let bindObj = &#123; type: 'bind'&#125;;let callObj = &#123; type: 'call'&#125;;function test() &#123; console.log(this.type)&#125;let bindTest = test.bind(bindObj)bindTest() // bindbindTest.call(callObj) // bindtest.call(callObj) // calltest.call() // global bind、call/apply指向绑定的对象，如果缺少传入值默认指向全局对象","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://getjll/tags/JavaScript/"}]},{"title":"vue2 生命周期 笔记","date":"2017-04-26T02:45:59.000Z","path":"2017/04/26/vue2 生命周期 笔记/","text":"生命周期图示 图片来自vue官网 生命周期钩子函数beforeCreate 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。 created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用之前。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 可以进行依赖DOM的操作 beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 可以在这个钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 可以执行依赖于 DOM 的操作 避免在此期间更改状态，可能会导致更新无限循环。 activated keep-alive 组件激活时调用。 deactivated keep-alive 组件停用时调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 可以进行组件销毁前的确认操作 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 可以进行自定义事件移除等的清理善后工作","tags":[{"name":"vue","slug":"vue","permalink":"http://getjll/tags/vue/"}]},{"title":"排序算法之快速排序","date":"2017-04-20T12:47:01.000Z","path":"2017/04/20/排序算法之快速排序/","text":"什么是快速排序 通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 上面的定义来自百度，我们进行拆解步骤如下：123选择一个基准值元素（这里方便直接选择第一项）所有项与基准值比对，小于的移动到左边，小于的移动到右边在左边和右边的区域，重复进行步骤1、2，直到数组内只有一个元素 JavaScript实现定义一个 quickSort 方法 123function quickSort(array) &#123;&#125; 检查数据只有一个元素时返回 12345function quickSort(array) &#123; if (array.length &lt;= 1) &#123; return array &#125;&#125; 遍历数组，小于基准放在左边，大于基准放在右边 12345678910111213141516171819function quickSort(array) &#123; if (array.length &lt;= 1) &#123; return array &#125; let baseItem = array[0]; let left = []; let right = []; array.forEach(function (item) &#123; if (item &lt; baseItem) &#123; left.push(item) &#125; if (item &gt; baseItem) &#123; right.push(item) &#125; &#125;)&#125; 最后递归左右集合后 合并返回 12345678910111213141516171819function quickSort(array) &#123; if (array.length &lt;= 1) &#123; return array &#125; let baseItem = array[0]; let left = []; let right = []; array.forEach(function (item) &#123; if (item &lt; baseItem) &#123; left.push(item) &#125; else if &#123; right.push(item) &#125; &#125;); return quickSort(left).concat([baseItem], quickSort(right))&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://getjll/tags/算法/"}]},{"title":"自定义域名 GitHub Pages 添加SSL","date":"2017-03-27T01:03:02.000Z","path":"2017/03/27/自定义域名GitHub Pages添加SSL/","text":"关于如何搭建GitHub Pages，请参考GitHub Pages + hexo搭建博客 写在前面为什么要给自己网站添加小绿锁? 提升逼格 防止中间劫持 大概步骤 注册cloudflare 添加域名解析 修改DNS服务器 设置Page Rules 注册cloudflare 没有cloudflare账户的同学先自己注册一个 添加你的域名，并解析 将 getjll.com 修改为你需要解析的域名，点击 Scan DNS Records。 这步是扫描你的DNS记录，等读秒结束点击下一步，你会看到下图 我这里是没有，需要自行添加 添加A，指向自定义域名 getjll.com 到 151.101.100.133（可以ping自己的GitHub Pages 得到） 添加CNAME，重定向 www.getjll.com 到 getjll.com aragorn.ns.cloudflare.com zita.ns.cloudflare.com cloudflare的DNS服务器，需要将域名DNS指定成这两个 修改DNS服务器 这里使用阿里云演示 进入阿里云的对应域名管理，点击DNS修改 输入在cloudflare得到的两个DNS服务器 返回cloudflare查看，设置正确结果 设置Page Rules","tags":[]},{"title":"GitHub Pages + hexo搭建博客","date":"2017-03-26T06:40:36.000Z","path":"2017/03/26/GitHub Pages-hexo搭建博客/","text":"本文介绍通过GitHub Pages + hexo 搭建个人博客 准备工作 注册github账户 使用 GitHub Pages 服务托管博客 安装node hexo基于 node 进行生成 安装Git 提交代码、blog代码进行版本控制 创建gitHub库 命令行创建 1$ curl -u \"userName\" https://api.github.com/user/repos -d '&#123;\"name\":\"'blogName'\"&#125;' userName 为你github用户名 blogName 你需要创建github库名字 这个库创建重要用于网站源代码的管理 网页创建 安装hexohexo基于node进行生成，请确保是否安装 node 环境 1$ npm i -g hexo-cli // 安装hexo模块 本地初始化博客依次输入以下命令 12$ cd ~/Desktop/ &amp;&amp; mkdir blog &amp;&amp; cd blog // 创建本地博客目录$ hexo init // 初始化博客 添加并关联远程仓库12$ git init$ git remote add git@github.com:getjll/blog.git 创建getjll.github.io仓库用于部署生成的静态页面 1$ curl -u \"userName\" https://api.github.com/user/repos -d '&#123;\"name\":\"'getjll.github.io'\"&#125;' 添加部署脚本1$ mkdir deploy.sh &amp;&amp; open deplay.sh 向 deploy.sh添加如下代码 1234567hexo cleanhexo gcd publicgit initgit add -Agit commit -m 'update site'git push -f git@github.com:getjll/getjll.github.io.git master // 这里替换成自己的分支 打开package.json文件向 scripts 添加如下字段 123\"scripts\": &#123; \"d\": \"sh ./deploy.sh\"&#125;, 部署命令 1$ npm run d 自定义域名1$ echo getjll.com source/CNAME getjll.com替换成你自己申请并解析的域名 hexo会将source的文件自动拷贝到生成目录","tags":[]}]